Dataset name: ProofWriter
Model name: qwen3-14b
Date: 20251201
Time: 125522

Total distinct IDs in dev: 601
Missing (no non-empty final_answer) in search_negation_True: 0

Missing (no non-empty final_answer) in search_negation_False: 0

Missing in at least one of the two files (under this definition): 0

Total evaluated instances: 601
Accuracy: 0.8303

Token Usage Statistics (restricted to evaluated IDs):
search_negation_True:
  prompt_tokens:
    min: 0 (id=ProofWriter_AttNeg-OWA-D5-285_Q16)
    max: 29379 (id=RelNoneg-OWA-D5-892)
    avg: 10993.28
  completion_tokens:
    min: 0 (id=ProofWriter_AttNeg-OWA-D5-285_Q16)
    max: 5411 (id=ProofWriter_RelNoneg-OWA-D5-213_Q19)
    avg: 1169.29
  total_tokens:
    min: 0 (id=ProofWriter_AttNeg-OWA-D5-285_Q16)
    max: 34730 (id=ProofWriter_RelNoneg-OWA-D5-213_Q19)
    avg: 12162.57

search_negation_False:
  prompt_tokens:
    min: 0 (id=ProofWriter_AttNoneg-OWA-D5-585_Q19)
    max: 29344 (id=ProofWriter_RelNoneg-OWA-D5-341_Q3)
    avg: 11450.62
  completion_tokens:
    min: 0 (id=ProofWriter_AttNoneg-OWA-D5-585_Q19)
    max: 4858 (id=ProofWriter_RelNoneg-OWA-D5-992_Q11)
    avg: 1227.12
  total_tokens:
    min: 0 (id=ProofWriter_AttNoneg-OWA-D5-585_Q19)
    max: 34178 (id=ProofWriter_RelNoneg-OWA-D5-992_Q11)
    avg: 12677.74

trans_decompose_no_negation:
  prompt_tokens:
    min: 1630 (id=ProofWriter_RelNoneg-OWA-D5-427_Q11)
    max: 5368 (id=ProofWriter_RelNoneg-OWA-D5-336_Q8)
    avg: 4749.06
  completion_tokens:
    min: 367 (id=RelNeg-OWA-D0-1457)
    max: 17289 (id=ProofWriter_RelNeg-OWA-D5-224_Q6)
    avg: 2165.93
  total_tokens:
    min: 4773 (id=RelNeg-OWA-D0-1457)
    max: 22506 (id=ProofWriter_RelNeg-OWA-D5-224_Q6)
    avg: 6914.99

Combined_per_ID_across_all_stages:
  prompt_tokens:
    min: 1630 (id=ProofWriter_RelNoneg-OWA-D5-427_Q11)
    max: 63432 (id=ProofWriter_RelNoneg-OWA-D5-992_Q11)
    avg: 27192.97
  completion_tokens:
    min: 367 (id=RelNeg-OWA-D0-1457)
    max: 18800 (id=ProofWriter_RelNeg-OWA-D5-224_Q6)
    avg: 4562.34
  total_tokens:
    min: 4773 (id=RelNeg-OWA-D0-1457)
    max: 74471 (id=ProofWriter_RelNoneg-OWA-D5-992_Q11)
    avg: 31755.30

Confusion Matrix (rows = ground truth, cols = prediction):
 	A	B	C	D
A	149	0	16	12
B	2	158	13	9
C	27	21	192	2
D	0	0	0	0

Per-class metrics:
Label A: Precision=0.8371, Recall=0.8418, TP=149, FP=29, FN=28
Label B: Precision=0.8827, Recall=0.8681, TP=158, FP=21, FN=24
Label C: Precision=0.8688, Recall=0.7934, TP=192, FP=29, FN=50
Label D: Precision=0.0000, Recall=0.0000, TP=0, FP=23, FN=0

Macro Precision: 0.6471, Macro Recall: 0.6258

Error ids:
AttNeg-OWA-D0-2279,AttNeg-OWA-D0-4322,AttNeg-OWA-D0-4390,AttNeg-OWA-D0-6467,AttNeg-OWA-D5-1154,AttNeg-OWA-D5-1166,AttNeg-OWA-D5-198,AttNeg-OWA-D5-683,AttNoneg-OWA-D0-2697,AttNoneg-OWA-D0-3065,AttNoneg-OWA-D0-6138,AttNoneg-OWA-D0-6844,AttNoneg-OWA-D0-9,AttNoneg-OWA-D5-1346,AttNoneg-OWA-D5-245,AttNoneg-OWA-D5-430,AttNoneg-OWA-D5-484,AttNoneg-OWA-D5-536,ProofWriter_AttNeg-OWA-D5-1149_Q18,ProofWriter_AttNeg-OWA-D5-1170_Q10,ProofWriter_AttNeg-OWA-D5-1183_Q16,ProofWriter_AttNeg-OWA-D5-1203_Q17,ProofWriter_AttNeg-OWA-D5-1208_Q1,ProofWriter_AttNeg-OWA-D5-1210_Q4,ProofWriter_AttNeg-OWA-D5-1233_Q11,ProofWriter_AttNeg-OWA-D5-145_Q9,ProofWriter_AttNeg-OWA-D5-195_Q3,ProofWriter_AttNeg-OWA-D5-200_Q12,ProofWriter_AttNeg-OWA-D5-315_Q16,ProofWriter_AttNeg-OWA-D5-327_Q17,ProofWriter_AttNeg-OWA-D5-333_Q16,ProofWriter_AttNeg-OWA-D5-347_Q14,ProofWriter_AttNeg-OWA-D5-465_Q1,ProofWriter_AttNeg-OWA-D5-523_Q7,ProofWriter_AttNeg-OWA-D5-532_Q21,ProofWriter_AttNeg-OWA-D5-562_Q11,ProofWriter_AttNeg-OWA-D5-779_Q20,ProofWriter_AttNeg-OWA-D5-804_Q1,ProofWriter_AttNeg-OWA-D5-804_Q16,ProofWriter_AttNeg-OWA-D5-891_Q18,ProofWriter_AttNeg-OWA-D5-904_Q14,ProofWriter_AttNeg-OWA-D5-927_Q19,ProofWriter_AttNeg-OWA-D5-973_Q19,ProofWriter_AttNoneg-OWA-D5-1057_Q5,ProofWriter_AttNoneg-OWA-D5-1066_Q12,ProofWriter_AttNoneg-OWA-D5-1095_Q14,ProofWriter_AttNoneg-OWA-D5-1187_Q7,ProofWriter_AttNoneg-OWA-D5-1205_Q16,ProofWriter_AttNoneg-OWA-D5-1335_Q7,ProofWriter_AttNoneg-OWA-D5-203_Q7,ProofWriter_AttNoneg-OWA-D5-20_Q10,ProofWriter_AttNoneg-OWA-D5-461_Q13,ProofWriter_AttNoneg-OWA-D5-718_Q9,ProofWriter_AttNoneg-OWA-D5-882_Q12,ProofWriter_AttNoneg-OWA-D5-882_Q2,ProofWriter_AttNoneg-OWA-D5-970_Q8,ProofWriter_RelNeg-OWA-D5-1029_Q2,ProofWriter_RelNeg-OWA-D5-115_Q11,ProofWriter_RelNeg-OWA-D5-129_Q8,ProofWriter_RelNeg-OWA-D5-183_Q3,ProofWriter_RelNeg-OWA-D5-262_Q17,ProofWriter_RelNeg-OWA-D5-266_Q3,ProofWriter_RelNeg-OWA-D5-317_Q13,ProofWriter_RelNeg-OWA-D5-345_Q22,ProofWriter_RelNeg-OWA-D5-345_Q9,ProofWriter_RelNeg-OWA-D5-430_Q15,ProofWriter_RelNeg-OWA-D5-430_Q21,ProofWriter_RelNeg-OWA-D5-561_Q16,ProofWriter_RelNeg-OWA-D5-602_Q16,ProofWriter_RelNeg-OWA-D5-604_Q14,ProofWriter_RelNeg-OWA-D5-70_Q11,ProofWriter_RelNeg-OWA-D5-721_Q6,ProofWriter_RelNeg-OWA-D5-721_Q8,ProofWriter_RelNeg-OWA-D5-77_Q15,ProofWriter_RelNeg-OWA-D5-856_Q12,ProofWriter_RelNeg-OWA-D5-856_Q6,ProofWriter_RelNeg-OWA-D5-890_Q11,ProofWriter_RelNeg-OWA-D5-902_Q8,ProofWriter_RelNeg-OWA-D5-922_Q10,ProofWriter_RelNoneg-OWA-D5-121_Q6,ProofWriter_RelNoneg-OWA-D5-121_Q8,ProofWriter_RelNoneg-OWA-D5-127_Q1,ProofWriter_RelNoneg-OWA-D5-251_Q21,ProofWriter_RelNoneg-OWA-D5-264_Q5,ProofWriter_RelNoneg-OWA-D5-272_Q14,ProofWriter_RelNoneg-OWA-D5-280_Q8,ProofWriter_RelNoneg-OWA-D5-334_Q15,ProofWriter_RelNoneg-OWA-D5-358_Q5,ProofWriter_RelNoneg-OWA-D5-427_Q11,ProofWriter_RelNoneg-OWA-D5-427_Q14,ProofWriter_RelNoneg-OWA-D5-595_Q3,ProofWriter_RelNoneg-OWA-D5-616_Q11,ProofWriter_RelNoneg-OWA-D5-861_Q14,ProofWriter_RelNoneg-OWA-D5-884_Q17,ProofWriter_RelNoneg-OWA-D5-977_Q5,ProofWriter_RelNoneg-OWA-D5-992_Q10,ProofWriter_RelNoneg-OWA-D5-992_Q11,RelNeg-OWA-D5-307,RelNoneg-OWA-D0-2570,RelNoneg-OWA-D0-2780,RelNoneg-OWA-D0-3914,RelNoneg-OWA-D0-4382

Correct ids:
AttNeg-OWA-D0-2242,AttNeg-OWA-D0-3145,AttNeg-OWA-D0-3706,AttNeg-OWA-D0-4005,AttNeg-OWA-D0-4684,AttNeg-OWA-D0-5750,AttNeg-OWA-D0-6188,AttNeg-OWA-D0-6787,AttNeg-OWA-D0-7103,AttNeg-OWA-D0-7187,AttNeg-OWA-D0-938,AttNeg-OWA-D5-1109,AttNeg-OWA-D5-1135,AttNeg-OWA-D5-1217,AttNeg-OWA-D5-345,AttNeg-OWA-D5-419,AttNeg-OWA-D5-439,AttNeg-OWA-D5-473,AttNeg-OWA-D5-800,AttNeg-OWA-D5-901,AttNoneg-OWA-D0-1270,AttNoneg-OWA-D0-1342,AttNoneg-OWA-D0-1650,AttNoneg-OWA-D0-1691,AttNoneg-OWA-D0-1737,AttNoneg-OWA-D0-2374,AttNoneg-OWA-D0-2710,AttNoneg-OWA-D0-3173,AttNoneg-OWA-D0-3364,AttNoneg-OWA-D0-380,AttNoneg-OWA-D0-3809,AttNoneg-OWA-D0-39,AttNoneg-OWA-D0-4563,AttNoneg-OWA-D0-4863,AttNoneg-OWA-D0-5352,AttNoneg-OWA-D0-5811,AttNoneg-OWA-D0-6733,AttNoneg-OWA-D0-7005,AttNoneg-OWA-D0-7124,AttNoneg-OWA-D5-1245,AttNoneg-OWA-D5-1270,AttNoneg-OWA-D5-1367,AttNoneg-OWA-D5-22,AttNoneg-OWA-D5-234,AttNoneg-OWA-D5-343,AttNoneg-OWA-D5-641,AttNoneg-OWA-D5-826,AttNoneg-OWA-D5-913,AttNoneg-OWA-D5-995,ProofWriter_AttNeg-OWA-D5-1015_Q3,ProofWriter_AttNeg-OWA-D5-1017_Q19,ProofWriter_AttNeg-OWA-D5-1017_Q5,ProofWriter_AttNeg-OWA-D5-1028_Q10,ProofWriter_AttNeg-OWA-D5-1066_Q21,ProofWriter_AttNeg-OWA-D5-107_Q1,ProofWriter_AttNeg-OWA-D5-107_Q6,ProofWriter_AttNeg-OWA-D5-108_Q15,ProofWriter_AttNeg-OWA-D5-109_Q11,ProofWriter_AttNeg-OWA-D5-109_Q13,ProofWriter_AttNeg-OWA-D5-1105_Q4,ProofWriter_AttNeg-OWA-D5-1111_Q2,ProofWriter_AttNeg-OWA-D5-1119_Q6,ProofWriter_AttNeg-OWA-D5-1149_Q12,ProofWriter_AttNeg-OWA-D5-1176_Q12,ProofWriter_AttNeg-OWA-D5-1183_Q20,ProofWriter_AttNeg-OWA-D5-1208_Q5,ProofWriter_AttNeg-OWA-D5-120_Q17,ProofWriter_AttNeg-OWA-D5-120_Q9,ProofWriter_AttNeg-OWA-D5-1210_Q8,ProofWriter_AttNeg-OWA-D5-1220_Q4,ProofWriter_AttNeg-OWA-D5-1220_Q6,ProofWriter_AttNeg-OWA-D5-1229_Q3,ProofWriter_AttNeg-OWA-D5-1229_Q6,ProofWriter_AttNeg-OWA-D5-1233_Q2,ProofWriter_AttNeg-OWA-D5-1236_Q12,ProofWriter_AttNeg-OWA-D5-1236_Q20,ProofWriter_AttNeg-OWA-D5-155_Q6,ProofWriter_AttNeg-OWA-D5-195_Q15,ProofWriter_AttNeg-OWA-D5-203_Q21,ProofWriter_AttNeg-OWA-D5-221_Q5,ProofWriter_AttNeg-OWA-D5-221_Q8,ProofWriter_AttNeg-OWA-D5-233_Q11,ProofWriter_AttNeg-OWA-D5-268_Q3,ProofWriter_AttNeg-OWA-D5-269_Q5,ProofWriter_AttNeg-OWA-D5-270_Q8,ProofWriter_AttNeg-OWA-D5-276_Q18,ProofWriter_AttNeg-OWA-D5-276_Q8,ProofWriter_AttNeg-OWA-D5-285_Q16,ProofWriter_AttNeg-OWA-D5-285_Q9,ProofWriter_AttNeg-OWA-D5-293_Q1,ProofWriter_AttNeg-OWA-D5-305_Q1,ProofWriter_AttNeg-OWA-D5-305_Q10,ProofWriter_AttNeg-OWA-D5-305_Q11,ProofWriter_AttNeg-OWA-D5-305_Q4,ProofWriter_AttNeg-OWA-D5-327_Q5,ProofWriter_AttNeg-OWA-D5-333_Q7,ProofWriter_AttNeg-OWA-D5-347_Q1,ProofWriter_AttNeg-OWA-D5-354_Q18,ProofWriter_AttNeg-OWA-D5-399_Q3,ProofWriter_AttNeg-OWA-D5-399_Q8,ProofWriter_AttNeg-OWA-D5-401_Q15,ProofWriter_AttNeg-OWA-D5-401_Q4,ProofWriter_AttNeg-OWA-D5-414_Q2,ProofWriter_AttNeg-OWA-D5-414_Q22,ProofWriter_AttNeg-OWA-D5-423_Q21,ProofWriter_AttNeg-OWA-D5-423_Q4,ProofWriter_AttNeg-OWA-D5-454_Q13,ProofWriter_AttNeg-OWA-D5-454_Q15,ProofWriter_AttNeg-OWA-D5-459_Q14,ProofWriter_AttNeg-OWA-D5-459_Q16,ProofWriter_AttNeg-OWA-D5-489_Q11,ProofWriter_AttNeg-OWA-D5-489_Q2,ProofWriter_AttNeg-OWA-D5-523_Q1,ProofWriter_AttNeg-OWA-D5-523_Q13,ProofWriter_AttNeg-OWA-D5-532_Q19,ProofWriter_AttNeg-OWA-D5-532_Q7,ProofWriter_AttNeg-OWA-D5-54_Q5,ProofWriter_AttNeg-OWA-D5-562_Q17,ProofWriter_AttNeg-OWA-D5-56_Q2,ProofWriter_AttNeg-OWA-D5-572_Q4,ProofWriter_AttNeg-OWA-D5-586_Q11,ProofWriter_AttNeg-OWA-D5-586_Q21,ProofWriter_AttNeg-OWA-D5-618_Q4,ProofWriter_AttNeg-OWA-D5-630_Q24,ProofWriter_AttNeg-OWA-D5-630_Q4,ProofWriter_AttNeg-OWA-D5-664_Q1,ProofWriter_AttNeg-OWA-D5-694_Q2,ProofWriter_AttNeg-OWA-D5-694_Q8,ProofWriter_AttNeg-OWA-D5-765_Q15,ProofWriter_AttNeg-OWA-D5-766_Q5,ProofWriter_AttNeg-OWA-D5-779_Q12,ProofWriter_AttNeg-OWA-D5-804_Q12,ProofWriter_AttNeg-OWA-D5-808_Q5,ProofWriter_AttNeg-OWA-D5-818_Q1,ProofWriter_AttNeg-OWA-D5-818_Q11,ProofWriter_AttNeg-OWA-D5-818_Q16,ProofWriter_AttNeg-OWA-D5-818_Q2,ProofWriter_AttNeg-OWA-D5-842_Q7,ProofWriter_AttNeg-OWA-D5-843_Q11,ProofWriter_AttNeg-OWA-D5-849_Q24,ProofWriter_AttNeg-OWA-D5-858_Q12,ProofWriter_AttNeg-OWA-D5-858_Q5,ProofWriter_AttNeg-OWA-D5-876_Q12,ProofWriter_AttNeg-OWA-D5-891_Q1,ProofWriter_AttNeg-OWA-D5-891_Q11,ProofWriter_AttNeg-OWA-D5-891_Q9,ProofWriter_AttNeg-OWA-D5-908_Q13,ProofWriter_AttNeg-OWA-D5-933_Q12,ProofWriter_AttNeg-OWA-D5-959_Q14,ProofWriter_AttNeg-OWA-D5-959_Q2,ProofWriter_AttNeg-OWA-D5-960_Q3,ProofWriter_AttNeg-OWA-D5-960_Q6,ProofWriter_AttNeg-OWA-D5-971_Q20,ProofWriter_AttNeg-OWA-D5-973_Q6,ProofWriter_AttNeg-OWA-D5-973_Q9,ProofWriter_AttNeg-OWA-D5-979_Q9,ProofWriter_AttNoneg-OWA-D5-1003_Q15,ProofWriter_AttNoneg-OWA-D5-1003_Q2,ProofWriter_AttNoneg-OWA-D5-1003_Q5,ProofWriter_AttNoneg-OWA-D5-1032_Q6,ProofWriter_AttNoneg-OWA-D5-1039_Q10,ProofWriter_AttNoneg-OWA-D5-1041_Q1,ProofWriter_AttNoneg-OWA-D5-1041_Q8,ProofWriter_AttNoneg-OWA-D5-1044_Q10,ProofWriter_AttNoneg-OWA-D5-1044_Q12,ProofWriter_AttNoneg-OWA-D5-1054_Q3,ProofWriter_AttNoneg-OWA-D5-1057_Q11,ProofWriter_AttNoneg-OWA-D5-1057_Q2,ProofWriter_AttNoneg-OWA-D5-1066_Q2,ProofWriter_AttNoneg-OWA-D5-1066_Q6,ProofWriter_AttNoneg-OWA-D5-1081_Q4,ProofWriter_AttNoneg-OWA-D5-1110_Q3,ProofWriter_AttNoneg-OWA-D5-1110_Q4,ProofWriter_AttNoneg-OWA-D5-1118_Q22,ProofWriter_AttNoneg-OWA-D5-111_Q2,ProofWriter_AttNoneg-OWA-D5-1122_Q9,ProofWriter_AttNoneg-OWA-D5-1164_Q9,ProofWriter_AttNoneg-OWA-D5-1169_Q1,ProofWriter_AttNoneg-OWA-D5-1205_Q12,ProofWriter_AttNoneg-OWA-D5-1250_Q15,ProofWriter_AttNoneg-OWA-D5-1251_Q1,ProofWriter_AttNoneg-OWA-D5-1251_Q3,ProofWriter_AttNoneg-OWA-D5-1258_Q18,ProofWriter_AttNoneg-OWA-D5-1284_Q8,ProofWriter_AttNoneg-OWA-D5-1286_Q7,ProofWriter_AttNoneg-OWA-D5-1304_Q8,ProofWriter_AttNoneg-OWA-D5-1330_Q11,ProofWriter_AttNoneg-OWA-D5-1331_Q16,ProofWriter_AttNoneg-OWA-D5-1364_Q16,ProofWriter_AttNoneg-OWA-D5-1421_Q1,ProofWriter_AttNoneg-OWA-D5-1421_Q11,ProofWriter_AttNoneg-OWA-D5-1421_Q14,ProofWriter_AttNoneg-OWA-D5-143_Q12,ProofWriter_AttNoneg-OWA-D5-143_Q6,ProofWriter_AttNoneg-OWA-D5-147_Q5,ProofWriter_AttNoneg-OWA-D5-165_Q11,ProofWriter_AttNoneg-OWA-D5-165_Q13,ProofWriter_AttNoneg-OWA-D5-177_Q19,ProofWriter_AttNoneg-OWA-D5-177_Q5,ProofWriter_AttNoneg-OWA-D5-178_Q11,ProofWriter_AttNoneg-OWA-D5-178_Q18,ProofWriter_AttNoneg-OWA-D5-178_Q3,ProofWriter_AttNoneg-OWA-D5-187_Q3,ProofWriter_AttNoneg-OWA-D5-187_Q7,ProofWriter_AttNoneg-OWA-D5-189_Q12,ProofWriter_AttNoneg-OWA-D5-1_Q1,ProofWriter_AttNoneg-OWA-D5-1_Q5,ProofWriter_AttNoneg-OWA-D5-301_Q16,ProofWriter_AttNoneg-OWA-D5-305_Q3,ProofWriter_AttNoneg-OWA-D5-305_Q9,ProofWriter_AttNoneg-OWA-D5-308_Q1,ProofWriter_AttNoneg-OWA-D5-308_Q8,ProofWriter_AttNoneg-OWA-D5-310_Q16,ProofWriter_AttNoneg-OWA-D5-327_Q1,ProofWriter_AttNoneg-OWA-D5-327_Q13,ProofWriter_AttNoneg-OWA-D5-352_Q8,ProofWriter_AttNoneg-OWA-D5-370_Q2,ProofWriter_AttNoneg-OWA-D5-370_Q4,ProofWriter_AttNoneg-OWA-D5-371_Q22,ProofWriter_AttNoneg-OWA-D5-412_Q4,ProofWriter_AttNoneg-OWA-D5-412_Q9,ProofWriter_AttNoneg-OWA-D5-461_Q16,ProofWriter_AttNoneg-OWA-D5-488_Q22,ProofWriter_AttNoneg-OWA-D5-492_Q6,ProofWriter_AttNoneg-OWA-D5-500_Q8,ProofWriter_AttNoneg-OWA-D5-515_Q4,ProofWriter_AttNoneg-OWA-D5-517_Q10,ProofWriter_AttNoneg-OWA-D5-528_Q6,ProofWriter_AttNoneg-OWA-D5-572_Q18,ProofWriter_AttNoneg-OWA-D5-583_Q11,ProofWriter_AttNoneg-OWA-D5-585_Q19,ProofWriter_AttNoneg-OWA-D5-613_Q10,ProofWriter_AttNoneg-OWA-D5-613_Q12,ProofWriter_AttNoneg-OWA-D5-620_Q19,ProofWriter_AttNoneg-OWA-D5-620_Q20,ProofWriter_AttNoneg-OWA-D5-622_Q13,ProofWriter_AttNoneg-OWA-D5-630_Q10,ProofWriter_AttNoneg-OWA-D5-650_Q11,ProofWriter_AttNoneg-OWA-D5-672_Q3,ProofWriter_AttNoneg-OWA-D5-677_Q2,ProofWriter_AttNoneg-OWA-D5-684_Q1,ProofWriter_AttNoneg-OWA-D5-689_Q2,ProofWriter_AttNoneg-OWA-D5-689_Q7,ProofWriter_AttNoneg-OWA-D5-692_Q4,ProofWriter_AttNoneg-OWA-D5-702_Q1,ProofWriter_AttNoneg-OWA-D5-702_Q7,ProofWriter_AttNoneg-OWA-D5-718_Q2,ProofWriter_AttNoneg-OWA-D5-718_Q3,ProofWriter_AttNoneg-OWA-D5-725_Q8,ProofWriter_AttNoneg-OWA-D5-735_Q12,ProofWriter_AttNoneg-OWA-D5-735_Q3,ProofWriter_AttNoneg-OWA-D5-735_Q9,ProofWriter_AttNoneg-OWA-D5-746_Q8,ProofWriter_AttNoneg-OWA-D5-746_Q9,ProofWriter_AttNoneg-OWA-D5-754_Q4,ProofWriter_AttNoneg-OWA-D5-781_Q5,ProofWriter_AttNoneg-OWA-D5-785_Q10,ProofWriter_AttNoneg-OWA-D5-785_Q5,ProofWriter_AttNoneg-OWA-D5-785_Q8,ProofWriter_AttNoneg-OWA-D5-83_Q10,ProofWriter_AttNoneg-OWA-D5-844_Q1,ProofWriter_AttNoneg-OWA-D5-844_Q7,ProofWriter_AttNoneg-OWA-D5-863_Q11,ProofWriter_AttNoneg-OWA-D5-866_Q17,ProofWriter_AttNoneg-OWA-D5-866_Q19,ProofWriter_AttNoneg-OWA-D5-877_Q16,ProofWriter_AttNoneg-OWA-D5-878_Q10,ProofWriter_AttNoneg-OWA-D5-878_Q5,ProofWriter_AttNoneg-OWA-D5-897_Q12,ProofWriter_AttNoneg-OWA-D5-897_Q4,ProofWriter_AttNoneg-OWA-D5-963_Q9,ProofWriter_AttNoneg-OWA-D5-971_Q5,ProofWriter_AttNoneg-OWA-D5-983_Q11,ProofWriter_AttNoneg-OWA-D5-983_Q7,ProofWriter_AttNoneg-OWA-D5-985_Q4,ProofWriter_AttNoneg-OWA-D5-999_Q1,ProofWriter_AttNoneg-OWA-D5-999_Q5,ProofWriter_RelNeg-OWA-D5-1026_Q13,ProofWriter_RelNeg-OWA-D5-1026_Q4,ProofWriter_RelNeg-OWA-D5-1029_Q10,ProofWriter_RelNeg-OWA-D5-111_Q9,ProofWriter_RelNeg-OWA-D5-115_Q19,ProofWriter_RelNeg-OWA-D5-115_Q3,ProofWriter_RelNeg-OWA-D5-144_Q18,ProofWriter_RelNeg-OWA-D5-169_Q5,ProofWriter_RelNeg-OWA-D5-169_Q6,ProofWriter_RelNeg-OWA-D5-173_Q10,ProofWriter_RelNeg-OWA-D5-174_Q18,ProofWriter_RelNeg-OWA-D5-195_Q8,ProofWriter_RelNeg-OWA-D5-199_Q4,ProofWriter_RelNeg-OWA-D5-224_Q4,ProofWriter_RelNeg-OWA-D5-224_Q6,ProofWriter_RelNeg-OWA-D5-226_Q19,ProofWriter_RelNeg-OWA-D5-226_Q3,ProofWriter_RelNeg-OWA-D5-226_Q4,ProofWriter_RelNeg-OWA-D5-242_Q23,ProofWriter_RelNeg-OWA-D5-249_Q10,ProofWriter_RelNeg-OWA-D5-249_Q9,ProofWriter_RelNeg-OWA-D5-266_Q24,ProofWriter_RelNeg-OWA-D5-278_Q22,ProofWriter_RelNeg-OWA-D5-294_Q2,ProofWriter_RelNeg-OWA-D5-294_Q3,ProofWriter_RelNeg-OWA-D5-29_Q18,ProofWriter_RelNeg-OWA-D5-29_Q21,ProofWriter_RelNeg-OWA-D5-317_Q2,ProofWriter_RelNeg-OWA-D5-330_Q11,ProofWriter_RelNeg-OWA-D5-345_Q12,ProofWriter_RelNeg-OWA-D5-355_Q4,ProofWriter_RelNeg-OWA-D5-406_Q4,ProofWriter_RelNeg-OWA-D5-40_Q24,ProofWriter_RelNeg-OWA-D5-419_Q14,ProofWriter_RelNeg-OWA-D5-419_Q24,ProofWriter_RelNeg-OWA-D5-437_Q1,ProofWriter_RelNeg-OWA-D5-442_Q24,ProofWriter_RelNeg-OWA-D5-442_Q5,ProofWriter_RelNeg-OWA-D5-455_Q24,ProofWriter_RelNeg-OWA-D5-478_Q5,ProofWriter_RelNeg-OWA-D5-483_Q10,ProofWriter_RelNeg-OWA-D5-483_Q6,ProofWriter_RelNeg-OWA-D5-491_Q15,ProofWriter_RelNeg-OWA-D5-498_Q15,ProofWriter_RelNeg-OWA-D5-498_Q8,ProofWriter_RelNeg-OWA-D5-508_Q2,ProofWriter_RelNeg-OWA-D5-510_Q5,ProofWriter_RelNeg-OWA-D5-510_Q7,ProofWriter_RelNeg-OWA-D5-527_Q10,ProofWriter_RelNeg-OWA-D5-527_Q22,ProofWriter_RelNeg-OWA-D5-555_Q8,ProofWriter_RelNeg-OWA-D5-568_Q9,ProofWriter_RelNeg-OWA-D5-574_Q12,ProofWriter_RelNeg-OWA-D5-585_Q1,ProofWriter_RelNeg-OWA-D5-585_Q24,ProofWriter_RelNeg-OWA-D5-587_Q11,ProofWriter_RelNeg-OWA-D5-587_Q13,ProofWriter_RelNeg-OWA-D5-587_Q8,ProofWriter_RelNeg-OWA-D5-602_Q13,ProofWriter_RelNeg-OWA-D5-604_Q12,ProofWriter_RelNeg-OWA-D5-650_Q17,ProofWriter_RelNeg-OWA-D5-661_Q24,ProofWriter_RelNeg-OWA-D5-668_Q14,ProofWriter_RelNeg-OWA-D5-668_Q8,ProofWriter_RelNeg-OWA-D5-68_Q2,ProofWriter_RelNeg-OWA-D5-68_Q7,ProofWriter_RelNeg-OWA-D5-70_Q15,ProofWriter_RelNeg-OWA-D5-70_Q21,ProofWriter_RelNeg-OWA-D5-745_Q8,ProofWriter_RelNeg-OWA-D5-747_Q21,ProofWriter_RelNeg-OWA-D5-75_Q5,ProofWriter_RelNeg-OWA-D5-785_Q10,ProofWriter_RelNeg-OWA-D5-785_Q16,ProofWriter_RelNeg-OWA-D5-78_Q12,ProofWriter_RelNeg-OWA-D5-813_Q17,ProofWriter_RelNeg-OWA-D5-829_Q2,ProofWriter_RelNeg-OWA-D5-829_Q6,ProofWriter_RelNeg-OWA-D5-829_Q7,ProofWriter_RelNeg-OWA-D5-856_Q19,ProofWriter_RelNeg-OWA-D5-890_Q2,ProofWriter_RelNeg-OWA-D5-902_Q5,ProofWriter_RelNeg-OWA-D5-903_Q6,ProofWriter_RelNeg-OWA-D5-922_Q7,ProofWriter_RelNeg-OWA-D5-925_Q22,ProofWriter_RelNeg-OWA-D5-940_Q9,ProofWriter_RelNeg-OWA-D5-947_Q2,ProofWriter_RelNeg-OWA-D5-948_Q14,ProofWriter_RelNeg-OWA-D5-948_Q21,ProofWriter_RelNeg-OWA-D5-966_Q21,ProofWriter_RelNeg-OWA-D5-966_Q7,ProofWriter_RelNeg-OWA-D5-995_Q6,ProofWriter_RelNoneg-OWA-D5-1009_Q18,ProofWriter_RelNoneg-OWA-D5-1036_Q2,ProofWriter_RelNoneg-OWA-D5-116_Q12,ProofWriter_RelNoneg-OWA-D5-116_Q3,ProofWriter_RelNoneg-OWA-D5-127_Q4,ProofWriter_RelNoneg-OWA-D5-131_Q1,ProofWriter_RelNoneg-OWA-D5-136_Q10,ProofWriter_RelNoneg-OWA-D5-136_Q24,ProofWriter_RelNoneg-OWA-D5-151_Q23,ProofWriter_RelNoneg-OWA-D5-173_Q17,ProofWriter_RelNoneg-OWA-D5-173_Q8,ProofWriter_RelNoneg-OWA-D5-213_Q19,ProofWriter_RelNoneg-OWA-D5-213_Q8,ProofWriter_RelNoneg-OWA-D5-230_Q19,ProofWriter_RelNoneg-OWA-D5-230_Q20,ProofWriter_RelNoneg-OWA-D5-251_Q10,ProofWriter_RelNoneg-OWA-D5-264_Q20,ProofWriter_RelNoneg-OWA-D5-272_Q16,ProofWriter_RelNoneg-OWA-D5-280_Q3,ProofWriter_RelNoneg-OWA-D5-298_Q21,ProofWriter_RelNoneg-OWA-D5-301_Q21,ProofWriter_RelNoneg-OWA-D5-312_Q22,ProofWriter_RelNoneg-OWA-D5-314_Q13,ProofWriter_RelNoneg-OWA-D5-31_Q12,ProofWriter_RelNoneg-OWA-D5-329_Q19,ProofWriter_RelNoneg-OWA-D5-329_Q6,ProofWriter_RelNoneg-OWA-D5-336_Q4,ProofWriter_RelNoneg-OWA-D5-336_Q8,ProofWriter_RelNoneg-OWA-D5-341_Q3,ProofWriter_RelNoneg-OWA-D5-365_Q1,ProofWriter_RelNoneg-OWA-D5-369_Q10,ProofWriter_RelNoneg-OWA-D5-398_Q21,ProofWriter_RelNoneg-OWA-D5-404_Q24,ProofWriter_RelNoneg-OWA-D5-410_Q24,ProofWriter_RelNoneg-OWA-D5-413_Q22,ProofWriter_RelNoneg-OWA-D5-428_Q12,ProofWriter_RelNoneg-OWA-D5-428_Q15,ProofWriter_RelNoneg-OWA-D5-428_Q17,ProofWriter_RelNoneg-OWA-D5-439_Q11,ProofWriter_RelNoneg-OWA-D5-439_Q2,ProofWriter_RelNoneg-OWA-D5-439_Q20,ProofWriter_RelNoneg-OWA-D5-439_Q21,ProofWriter_RelNoneg-OWA-D5-439_Q23,ProofWriter_RelNoneg-OWA-D5-469_Q24,ProofWriter_RelNoneg-OWA-D5-481_Q23,ProofWriter_RelNoneg-OWA-D5-487_Q10,ProofWriter_RelNoneg-OWA-D5-487_Q19,ProofWriter_RelNoneg-OWA-D5-487_Q5,ProofWriter_RelNoneg-OWA-D5-502_Q3,ProofWriter_RelNoneg-OWA-D5-521_Q16,ProofWriter_RelNoneg-OWA-D5-559_Q20,ProofWriter_RelNoneg-OWA-D5-559_Q24,ProofWriter_RelNoneg-OWA-D5-566_Q22,ProofWriter_RelNoneg-OWA-D5-581_Q1,ProofWriter_RelNoneg-OWA-D5-637_Q19,ProofWriter_RelNoneg-OWA-D5-649_Q1,ProofWriter_RelNoneg-OWA-D5-683_Q1,ProofWriter_RelNoneg-OWA-D5-683_Q22,ProofWriter_RelNoneg-OWA-D5-683_Q4,ProofWriter_RelNoneg-OWA-D5-685_Q24,ProofWriter_RelNoneg-OWA-D5-685_Q8,ProofWriter_RelNoneg-OWA-D5-686_Q18,ProofWriter_RelNoneg-OWA-D5-691_Q10,ProofWriter_RelNoneg-OWA-D5-691_Q3,ProofWriter_RelNoneg-OWA-D5-709_Q1,ProofWriter_RelNoneg-OWA-D5-726_Q6,ProofWriter_RelNoneg-OWA-D5-739_Q12,ProofWriter_RelNoneg-OWA-D5-745_Q18,ProofWriter_RelNoneg-OWA-D5-754_Q23,ProofWriter_RelNoneg-OWA-D5-76_Q13,ProofWriter_RelNoneg-OWA-D5-76_Q8,ProofWriter_RelNoneg-OWA-D5-775_Q9,ProofWriter_RelNoneg-OWA-D5-777_Q6,ProofWriter_RelNoneg-OWA-D5-777_Q9,ProofWriter_RelNoneg-OWA-D5-781_Q8,ProofWriter_RelNoneg-OWA-D5-789_Q21,ProofWriter_RelNoneg-OWA-D5-789_Q23,ProofWriter_RelNoneg-OWA-D5-789_Q9,ProofWriter_RelNoneg-OWA-D5-796_Q6,ProofWriter_RelNoneg-OWA-D5-816_Q7,ProofWriter_RelNoneg-OWA-D5-829_Q7,ProofWriter_RelNoneg-OWA-D5-861_Q16,ProofWriter_RelNoneg-OWA-D5-861_Q3,ProofWriter_RelNoneg-OWA-D5-873_Q17,ProofWriter_RelNoneg-OWA-D5-90_Q13,ProofWriter_RelNoneg-OWA-D5-949_Q22,ProofWriter_RelNoneg-OWA-D5-949_Q24,ProofWriter_RelNoneg-OWA-D5-949_Q5,ProofWriter_RelNoneg-OWA-D5-949_Q8,ProofWriter_RelNoneg-OWA-D5-960_Q10,ProofWriter_RelNoneg-OWA-D5-960_Q12,ProofWriter_RelNoneg-OWA-D5-975_Q15,ProofWriter_RelNoneg-OWA-D5-975_Q22,ProofWriter_RelNoneg-OWA-D5-975_Q4,ProofWriter_RelNoneg-OWA-D5-977_Q14,ProofWriter_RelNoneg-OWA-D5-977_Q22,ProofWriter_RelNoneg-OWA-D5-977_Q3,ProofWriter_RelNoneg-OWA-D5-983_Q24,ProofWriter_RelNoneg-OWA-D5-983_Q3,ProofWriter_RelNoneg-OWA-D5-992_Q8,RelNeg-OWA-D0-1318,RelNeg-OWA-D0-1457,RelNeg-OWA-D0-1956,RelNeg-OWA-D0-2349,RelNeg-OWA-D0-2509,RelNeg-OWA-D0-3266,RelNeg-OWA-D0-3309,RelNeg-OWA-D0-4174,RelNeg-OWA-D0-5122,RelNeg-OWA-D0-5138,RelNeg-OWA-D0-5805,RelNeg-OWA-D0-6129,RelNeg-OWA-D0-6172,RelNeg-OWA-D0-796,RelNeg-OWA-D0-806,RelNeg-OWA-D5-329,RelNoneg-OWA-D0-2246,RelNoneg-OWA-D0-2506,RelNoneg-OWA-D0-2794,RelNoneg-OWA-D0-2880,RelNoneg-OWA-D0-3667,RelNoneg-OWA-D0-3822,RelNoneg-OWA-D0-4672,RelNoneg-OWA-D0-4879,RelNoneg-OWA-D0-4884,RelNoneg-OWA-D0-5182,RelNoneg-OWA-D0-5338,RelNoneg-OWA-D5-1019,RelNoneg-OWA-D5-26,RelNoneg-OWA-D5-392,RelNoneg-OWA-D5-892


Example errors per (ground_truth, prediction) cell:
Ground truth: A, Predicted: C
  id: ProofWriter_AttNeg-OWA-D5-145_Q9
  original_context: Anne is kind. Anne is quiet. Anne is smart. Bob is kind. Bob is nice. Bob is smart. Fiona is not nice. Fiona is red. Gary is nice. Gary is white. If Bob is kind then Bob is smart. If something is kind and nice then it is smart. If something is nice and red then it is smart. If something is quiet and not nice then it is smart. All green things are kind. If Anne is quiet and Anne is white then Anne is kind. If Fiona is not nice then Fiona is green. All smart, kind things are white. If something is kind and green then it is quiet.
  question:  Fiona is smart.
  ground_truth: A
  predicted_label: C
  search_negation_True final_choice: No final answer found in the text.
  search_negation_True final_answer: No final answer found in the text.
  search_negation_True reasoning_step: 1. ['Smart(Fiona, False) ', 'Nice(x, False) ∨ Red(x, False) ∨ Smart(x, True)', 'Nice(Fiona, False) ∨ Red(Fiona, False)']
2. ['Nice(Fiona, False) ∨ Red(Fiona, False)', 'Nice(Fiona, True) ∨ Green(Fiona, True)', 'Red(Fiona, False) ∨ Green(Fiona, True)']
3. ['Red(Fiona, False) ∨ Green(Fiona, True)', 'Red(Fiona, True)', 'Green(Fiona, True)']
4. ['Green(Fiona, True)', 'Green(x, False) ∨ Kind(x, True)', 'Kind(Fiona, True)']
5. ['Kind(Fiona, True)', '(Kind(x, False) ∨ White(x, True))', 'White(Fiona, True)']
6. ['Smart(Fiona, False) ', 'Kind(x, False) ∨ Nice(x, False) ∨ Smart(x, True)', 'Kind(Fiona, False) ∨ Nice(Fiona, False)']
7. ['Kind(Fiona, False) ∨ Nice(Fiona, False)', 'Kind(Fiona, True)', 'Nice(Fiona, False)']
8. ['Nice(Fiona, False)', 'Nice(Fiona, True) ∨ Green(Fiona, True)', 'Green(Fiona, True)']
9. ['Green(Fiona, True)', 'Kind(x, False) ∨ Green(x, False) ∨ Quiet(x, True)', 'Kind(Fiona, False) ∨ Quiet(Fiona, True)']
10. ['Kind(Fiona, False) ∨ Quiet(Fiona, True)', 'Kind(Fiona, True)', 'Quiet(Fiona, True)']
  search_negation_True translated_context: {'Translated_Facts': 'Kind(Anne, True) ::: Anne is kind.\nQuiet(Anne, True) ::: Anne is quiet.\nSmart(Anne, True) ::: Anne is smart.\nKind(Bob, True) ::: Bob is kind.\nNice(Bob, True) ::: Bob is nice.\nSmart(Bob, True) ::: Bob is smart.\nNice(Fiona, False) ::: Fiona is not nice.\nRed(Fiona, True) ::: Fiona is red.\nNice(Gary, True) ::: Gary is nice.\nWhite(Gary, True) ::: Gary is white.', 'Translated_Rules': '**\n\nGreen($x, True) >>> Kind($x, True) ::: All green things are kind.\n\n**Conditional rules:**\n\nKind(Bob, True) >>> Smart(Bob, True) ::: If Bob is kind then Bob is smart.  \nKind($x, True) && Nice($x, True) >>> Smart($x, True) ::: If something is kind and nice then it is smart.  \nNice($x, True) && Red($x, True) >>> Smart($x, True) ::: If something is nice and red then it is smart.  \nQuiet($x, True) && Nice($x, False) >>> Smart($x, True) ::: If something is quiet and not nice then it is smart.  \nQuiet(Anne, True) && White(Anne, True) >>> Kind(Anne, True) ::: If Anne is quiet and Anne is white then Anne is kind.  \nNice(Fiona, False) >>> Green(Fiona, True) ::: If Fiona is not nice then Fiona is green.  \nSmart($x, True) && Kind($x, True) >>> White($x, True) ::: All smart, kind things are white.  \nKind($x, True) && Green($x, True) >>> Quiet($x, True) ::: If something is kind and green then it is quiet.\n\n**Rules with Compound Predicates by Comma:**\n\nSmart($x, True) ∨ Kind($x, True) >>> White($x, True) ::: All smart, kind things are white.  \nKind($x, True) ∨ Green($x, True) >>> Quiet($x, True) ::: If something is kind and green then it is quiet.\n\n**', 'Translated_Conjecture': '**\nSmart(Fiona, True) ::: Fiona is smart.'}
  search_negation_True normalized_context: {'Fact': 'Kind(Anne, True) ::: Anne is kind.\nQuiet(Anne, True) ::: Anne is quiet.\nSmart(Anne, True) ::: Anne is smart.\nKind(Bob, True) ::: Bob is kind.\nNice(Bob, True) ::: Bob is nice.\nSmart(Bob, True) ::: Bob is smart.\nNice(Fiona, False) ::: Fiona is not nice.\nRed(Fiona, True) ::: Fiona is red.\nNice(Gary, True) ::: Gary is nice.\nWhite(Gary, True) ::: Gary is white.', 'and_or': 'Green(x, False) ∨ Kind(x, True)\nKind(Bob, False) ∨ Smart(Bob, True)\nKind(x, False) ∨ Nice(x, False) ∨ Smart(x, True)\nNice(x, False) ∨ Red(x, False) ∨ Smart(x, True)\nQuiet(x, False) ∨ Nice(x, True) ∨ Smart(x, True)\nQuiet(Anne, False) ∨ White(Anne, False) ∨ Kind(Anne, True)\nNice(Fiona, True) ∨ Green(Fiona, True)\nSmart(x, False) ∨ Kind(x, False) ∨ White(x, True)\nKind(x, False) ∨ Green(x, False) ∨ Quiet(x, True)\n(Smart(x, False) ∨ White(x, True)) ∧ (Kind(x, False) ∨ White(x, True))', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: No final answer found in the text.
  search_negation_False final_answer: No complement found in both context and cache.
  search_negation_False reasoning_step: 1. ['Smart(Fiona, True) ', '(Smart(x, False) ∨ White(x, True))', 'White(Fiona, True)']
2. ['Smart(Fiona, True) ', 'Smart(x, False) ∨ Kind(x, False) ∨ White(x, True)', 'Kind(Fiona, False) ∨ White(Fiona, True)']
3. ['Kind(Fiona, False) ∨ White(Fiona, True)', 'Green(x, False) ∨ Kind(x, True)', 'White(Fiona, True) ∨ Green(Fiona, False)']
  search_negation_False translated_context: {'Translated_Facts': 'Kind(Anne, True) ::: Anne is kind.\nQuiet(Anne, True) ::: Anne is quiet.\nSmart(Anne, True) ::: Anne is smart.\nKind(Bob, True) ::: Bob is kind.\nNice(Bob, True) ::: Bob is nice.\nSmart(Bob, True) ::: Bob is smart.\nNice(Fiona, False) ::: Fiona is not nice.\nRed(Fiona, True) ::: Fiona is red.\nNice(Gary, True) ::: Gary is nice.\nWhite(Gary, True) ::: Gary is white.', 'Translated_Rules': '**\n\nGreen($x, True) >>> Kind($x, True) ::: All green things are kind.\n\n**Conditional rules:**\n\nKind(Bob, True) >>> Smart(Bob, True) ::: If Bob is kind then Bob is smart.  \nKind($x, True) && Nice($x, True) >>> Smart($x, True) ::: If something is kind and nice then it is smart.  \nNice($x, True) && Red($x, True) >>> Smart($x, True) ::: If something is nice and red then it is smart.  \nQuiet($x, True) && Nice($x, False) >>> Smart($x, True) ::: If something is quiet and not nice then it is smart.  \nQuiet(Anne, True) && White(Anne, True) >>> Kind(Anne, True) ::: If Anne is quiet and Anne is white then Anne is kind.  \nNice(Fiona, False) >>> Green(Fiona, True) ::: If Fiona is not nice then Fiona is green.  \nSmart($x, True) && Kind($x, True) >>> White($x, True) ::: All smart, kind things are white.  \nKind($x, True) && Green($x, True) >>> Quiet($x, True) ::: If something is kind and green then it is quiet.\n\n**Rules with Compound Predicates by Comma:**\n\nSmart($x, True) ∨ Kind($x, True) >>> White($x, True) ::: All smart, kind things are white.  \nKind($x, True) ∨ Green($x, True) >>> Quiet($x, True) ::: If something is kind and green then it is quiet.\n\n**', 'Translated_Conjecture': '**\nSmart(Fiona, True) ::: Fiona is smart.'}
  search_negation_False normalized_context: {'Fact': 'Kind(Anne, True) ::: Anne is kind.\nQuiet(Anne, True) ::: Anne is quiet.\nSmart(Anne, True) ::: Anne is smart.\nKind(Bob, True) ::: Bob is kind.\nNice(Bob, True) ::: Bob is nice.\nSmart(Bob, True) ::: Bob is smart.\nNice(Fiona, False) ::: Fiona is not nice.\nRed(Fiona, True) ::: Fiona is red.\nNice(Gary, True) ::: Gary is nice.\nWhite(Gary, True) ::: Gary is white.', 'and_or': 'Green(x, False) ∨ Kind(x, True)\nKind(Bob, False) ∨ Smart(Bob, True)\nKind(x, False) ∨ Nice(x, False) ∨ Smart(x, True)\nNice(x, False) ∨ Red(x, False) ∨ Smart(x, True)\nQuiet(x, False) ∨ Nice(x, True) ∨ Smart(x, True)\nQuiet(Anne, False) ∨ White(Anne, False) ∨ Kind(Anne, True)\nNice(Fiona, True) ∨ Green(Fiona, True)\nSmart(x, False) ∨ Kind(x, False) ∨ White(x, True)\nKind(x, False) ∨ Green(x, False) ∨ Quiet(x, True)\n(Smart(x, False) ∨ White(x, True)) ∧ (Kind(x, False) ∨ White(x, True))', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=C, False_run=C)

Ground truth: A, Predicted: D
  id: ProofWriter_AttNeg-OWA-D5-1208_Q1
  original_context: Anne is cold. Anne is not green. Anne is not kind. Anne is quiet. Anne is round. Bob is kind. Bob is round. Charlie is cold. Charlie is quiet. Charlie is round. Erin is furry. If something is quiet then it is rough. Cold things are round. If something is green then it is quiet. All cold things are quiet. Green things are quiet. If something is kind and green then it is furry. Furry things are green. If Bob is kind then Bob is not rough. If something is rough and green then it is cold.
  question:  Anne is round.
  ground_truth: A
  predicted_label: D
  search_negation_True final_choice: A
  search_negation_True final_answer: True
  search_negation_True reasoning_step: 1. ['Round(Anne, False) ', 'Round(Anne, True)', 'Contradiction']
  search_negation_True translated_context: {'Translated_Facts': 'Cold(Anne, True) ::: Anne is cold.\nGreen(Anne, False) ::: Anne is not green.\nKind(Anne, False) ::: Anne is not kind.\nQuiet(Anne, True) ::: Anne is quiet.\nRound(Anne, True) ::: Anne is round.\nKind(Bob, True) ::: Bob is kind.\nRound(Bob, True) ::: Bob is round.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRound(Charlie, True) ::: Charlie is round.\nFurry(Erin, True) ::: Erin is furry.', 'Translated_Rules': '**\n\n**Rules with compound predicates by comma:**\nQuiet($x, True) ∨ Round($x, True) >>> Rough($x, True) ::: If something is quiet then it is rough.  \nCold($x, True) ∨ Round($x, True) >>> Round($x, True) ::: Cold things are round.  \nGreen($x, True) ∨ Quiet($x, True) >>> Quiet($x, True) ::: Green things are quiet.  \nKind($x, True) ∨ Green($x, True) >>> Furry($x, True) ::: If something is kind and green then it is furry.  \nFurry($x, True) ∨ Green($x, True) >>> Green($x, True) ::: Furry things are green.  \nRough($x, True) ∨ Green($x, True) >>> Cold($x, True) ::: If something is rough and green then it is cold.\n\n**Conditional rules:**\nQuiet(Anne, True) >>> Rough(Anne, True) ::: If something is quiet then it is rough.  \nCold($x, True) >>> Quiet($x, True) ::: All cold things are quiet.  \nKind(Bob, True) >>> Rough(Bob, False) ::: If Bob is kind then Bob is not rough.\n\n**', 'Translated_Conjecture': '**\nRound(Anne, True) ::: Anne is round.'}
  search_negation_True normalized_context: {'Fact': 'Cold(Anne, True) ::: Anne is cold.\nGreen(Anne, False) ::: Anne is not green.\nKind(Anne, False) ::: Anne is not kind.\nQuiet(Anne, True) ::: Anne is quiet.\nRound(Anne, True) ::: Anne is round.\nKind(Bob, True) ::: Bob is kind.\nRound(Bob, True) ::: Bob is round.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRound(Charlie, True) ::: Charlie is round.\nFurry(Erin, True) ::: Erin is furry.', 'and_or': '(Rough(x, True) ∨ ¬Quiet(x, True)) ∧ (Rough(x, True) ∨ ¬Round(x, True))\n(Round(x, True) ∨ ¬Cold(x, True)) ∧ (Round(x, True) ∨ ¬Round(x, True))\n(Quiet(x, True) ∨ ¬Green(x, True)) ∧ (Quiet(x, True) ∨ ¬Quiet(x, True))\n(Furry(x, True) ∨ ¬Kind(x, True)) ∧ (Furry(x, True) ∨ ¬Green(x, True))\n(Green(x, True) ∨ ¬Furry(x, True)) ∧ (Green(x, True) ∨ ¬Green(x, True))\n(Cold(x, True) ∨ ¬Rough(x, True)) ∧ (Cold(x, True) ∨ ¬Green(x, True))\n¬Quiet(Anne, True) ∨ Rough(Anne, True)\n¬Cold(x, True) ∨ Quiet(x, True)\n¬Kind(Bob, True) ∨ Rough(Bob, False)', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: B
  search_negation_False final_answer: False
  search_negation_False reasoning_step: 1. ['Round(Anne, True) ', '(Rough(x, True) ∨ Round(x, False))', 'Rough(Anne, True)']
2. ['Rough(Anne, True)', '(Cold(x, True) ∨ Rough(x, False))', 'Cold(Anne, True)']
3. ['Cold(Anne, True)', 'Cold(x, False) ∨ Quiet(x, True)', 'Quiet(Anne, True)']
4. ['Quiet(Anne, True)', '(Rough(x, True) ∨ Quiet(x, False))', 'Rough(Anne, True)']
5. ['Round(Anne, True) ', '(Round(x, True) ∨ Round(x, False))', 'Round(Anne, False)']
6. ['Round(Anne, False)', 'Round(Anne, True)', 'Contradiction']
  search_negation_False translated_context: {'Translated_Facts': 'Cold(Anne, True) ::: Anne is cold.\nGreen(Anne, False) ::: Anne is not green.\nKind(Anne, False) ::: Anne is not kind.\nQuiet(Anne, True) ::: Anne is quiet.\nRound(Anne, True) ::: Anne is round.\nKind(Bob, True) ::: Bob is kind.\nRound(Bob, True) ::: Bob is round.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRound(Charlie, True) ::: Charlie is round.\nFurry(Erin, True) ::: Erin is furry.', 'Translated_Rules': '**\n\n**Rules with compound predicates by comma:**\nQuiet($x, True) ∨ Round($x, True) >>> Rough($x, True) ::: If something is quiet then it is rough.  \nCold($x, True) ∨ Round($x, True) >>> Round($x, True) ::: Cold things are round.  \nGreen($x, True) ∨ Quiet($x, True) >>> Quiet($x, True) ::: Green things are quiet.  \nKind($x, True) ∨ Green($x, True) >>> Furry($x, True) ::: If something is kind and green then it is furry.  \nFurry($x, True) ∨ Green($x, True) >>> Green($x, True) ::: Furry things are green.  \nRough($x, True) ∨ Green($x, True) >>> Cold($x, True) ::: If something is rough and green then it is cold.\n\n**Conditional rules:**\nQuiet(Anne, True) >>> Rough(Anne, True) ::: If something is quiet then it is rough.  \nCold($x, True) >>> Quiet($x, True) ::: All cold things are quiet.  \nKind(Bob, True) >>> Rough(Bob, False) ::: If Bob is kind then Bob is not rough.\n\n**', 'Translated_Conjecture': '**\nRound(Anne, True) ::: Anne is round.'}
  search_negation_False normalized_context: {'Fact': 'Cold(Anne, True) ::: Anne is cold.\nGreen(Anne, False) ::: Anne is not green.\nKind(Anne, False) ::: Anne is not kind.\nQuiet(Anne, True) ::: Anne is quiet.\nRound(Anne, True) ::: Anne is round.\nKind(Bob, True) ::: Bob is kind.\nRound(Bob, True) ::: Bob is round.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, True) ::: Charlie is quiet.\nRound(Charlie, True) ::: Charlie is round.\nFurry(Erin, True) ::: Erin is furry.', 'and_or': '(Rough(x, True) ∨ ¬Quiet(x, True)) ∧ (Rough(x, True) ∨ ¬Round(x, True))\n(Round(x, True) ∨ ¬Cold(x, True)) ∧ (Round(x, True) ∨ ¬Round(x, True))\n(Quiet(x, True) ∨ ¬Green(x, True)) ∧ (Quiet(x, True) ∨ ¬Quiet(x, True))\n(Furry(x, True) ∨ ¬Kind(x, True)) ∧ (Furry(x, True) ∨ ¬Green(x, True))\n(Green(x, True) ∨ ¬Furry(x, True)) ∧ (Green(x, True) ∨ ¬Green(x, True))\n(Cold(x, True) ∨ ¬Rough(x, True)) ∧ (Cold(x, True) ∨ ¬Green(x, True))\n¬Quiet(Anne, True) ∨ Rough(Anne, True)\n¬Cold(x, True) ∨ Quiet(x, True)\n¬Kind(Bob, True) ∨ Rough(Bob, False)', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=A, False_run=B)

Ground truth: B, Predicted: A
  id: AttNeg-OWA-D5-683
  original_context: Anne is furry. Anne is quiet. Charlie is furry. Charlie is green. Dave is furry. Dave is young. Fiona is furry. If something is green and furry then it is quiet. Young things are quiet. If something is quiet then it is green. Smart, nice things are green. All nice things are furry. All nice things are not smart. Furry things are young. All furry things are cold. All green, quiet things are nice.
  question:  Anne is smart.
  ground_truth: B
  predicted_label: A
  search_negation_True final_choice: A
  search_negation_True final_answer: True
  search_negation_True reasoning_step: 1. ['Smart(Anne, True) ', '(Green(x,True) ∨ Smart(x,False))', 'Green(Anne, True)']
2. ['Green(Anne, True)', '(Nice(x,True) ∨ Green(x,False))', 'Nice(Anne, True)']
3. ['Nice(Anne, True)', '(Green(x,True) ∨ Nice(x,False))', 'Green(Anne, True)']
4. ['Green(Anne, True)', '(Quiet(x,True) ∨ Green(x,False))', 'Quiet(Anne, True)']
5. ['Quiet(Anne, True)', '(Nice(x,True) ∨ Quiet(x,False))', 'Nice(Anne, True)']
6. ['Nice(Anne, True)', '(Nice(x,False) ∨ Furry(x,True))', 'Furry(Anne, True)']
7. ['Furry(Anne, True)', '(Furry(x,False) ∨ Cold(x,True))', 'Cold(Anne, True)']
8. ['Smart(Anne, True) ', '(Nice(x,False) ∨ Smart(x,False))', 'Nice(Anne, False)']
9. ['Nice(Anne, False)', 'Nice(Anne, True)', 'Contradiction']
  search_negation_True translated_context: {'Translated_Facts': 'Furry(Anne, True) ::: Anne is furry.\nQuiet(Anne, True) ::: Anne is quiet.\nFurry(Charlie, True) ::: Charlie is furry.\nGreen(Charlie, True) ::: Charlie is green.\nFurry(Dave, True) ::: Dave is furry.\nYoung(Dave, True) ::: Dave is young.\nFurry(Fiona, True) ::: Fiona is furry.', 'Translated_Rules': '**\n\n**Rules with compound predicates by comma:**\nGreen($x, True) ∨ Furry($x, True) >>> Quiet($x, True) ::: If something is green and furry then it is quiet.  \nYoung($x, True) >>> Quiet($x, True) ::: Young things are quiet.  \nQuiet($x, True) >>> Green($x, True) ::: If something is quiet then it is green.  \nSmart($x, True) ∨ Nice($x, True) >>> Green($x, True) ::: Smart, nice things are green.  \nNice($x, True) >>> Furry($x, True) ::: All nice things are furry.  \nNice($x, True) >>> ¬Smart($x, True) ::: All nice things are not smart.  \nFurry($x, True) >>> Young($x, True) ::: Furry things are young.  \nFurry($x, True) >>> Cold($x, True) ::: All furry things are cold.  \nGreen($x, True) ∨ Quiet($x, True) >>> Nice($x, True) ::: All green, quiet things are nice.\n\n**Conditional rules:**\n(No conditional rules with "if" are present in the context that are not already captured in the rules above.)\n\n**', 'Translated_Conjecture': '**\nSmart(Anne, False) ::: Anne is smart. (Note: The conjecture is phrased as "Anne is smart," which is a claim to be evaluated. In logic form, it is represented as Smart(Anne, True), but since the task is to evaluate the truth of the conjecture, we represent it as a claim to be validated.)'}
  search_negation_True normalized_context: {'Fact': 'Furry(Anne, True) ::: Anne is furry.\nQuiet(Anne, True) ::: Anne is quiet.\nFurry(Charlie, True) ::: Charlie is furry.\nGreen(Charlie, True) ::: Charlie is green.\nFurry(Dave, True) ::: Dave is furry.\nYoung(Dave, True) ::: Dave is young.\nFurry(Fiona, True) ::: Fiona is furry.', 'and_or': '(Quiet(x,True) ∨ ¬Green(x,True)) ∧ (Quiet(x,True) ∨ ¬Furry(x,True))\n∧ (¬Young(x,True) ∨ Quiet(x,True))\n∧ (¬Quiet(x,True) ∨ Green(x,True))\n∧ (Green(x,True) ∨ ¬Smart(x,True)) ∧ (Green(x,True) ∨ ¬Nice(x,True))\n∧ (¬Nice(x,True) ∨ Furry(x,True))\n∧ (¬Nice(x,True) ∨ ¬Smart(x,True))\n∧ (¬Furry(x,True) ∨ Young(x,True))\n∧ (¬Furry(x,True) ∨ Cold(x,True))\n∧ (Nice(x,True) ∨ ¬Green(x,True)) ∧ (Nice(x,True) ∨ ¬Quiet(x,True))', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: No final answer found in the text.
  search_negation_False final_answer: No complement found in the context.
  search_negation_False reasoning_step: 
  search_negation_False translated_context: {'Translated_Facts': 'Furry(Anne, True) ::: Anne is furry.\nQuiet(Anne, True) ::: Anne is quiet.\nFurry(Charlie, True) ::: Charlie is furry.\nGreen(Charlie, True) ::: Charlie is green.\nFurry(Dave, True) ::: Dave is furry.\nYoung(Dave, True) ::: Dave is young.\nFurry(Fiona, True) ::: Fiona is furry.', 'Translated_Rules': '**\n\n**Rules with compound predicates by comma:**\nGreen($x, True) ∨ Furry($x, True) >>> Quiet($x, True) ::: If something is green and furry then it is quiet.  \nYoung($x, True) >>> Quiet($x, True) ::: Young things are quiet.  \nQuiet($x, True) >>> Green($x, True) ::: If something is quiet then it is green.  \nSmart($x, True) ∨ Nice($x, True) >>> Green($x, True) ::: Smart, nice things are green.  \nNice($x, True) >>> Furry($x, True) ::: All nice things are furry.  \nNice($x, True) >>> ¬Smart($x, True) ::: All nice things are not smart.  \nFurry($x, True) >>> Young($x, True) ::: Furry things are young.  \nFurry($x, True) >>> Cold($x, True) ::: All furry things are cold.  \nGreen($x, True) ∨ Quiet($x, True) >>> Nice($x, True) ::: All green, quiet things are nice.\n\n**Conditional rules:**\n(No conditional rules with "if" are present in the context that are not already captured in the rules above.)\n\n**', 'Translated_Conjecture': '**\nSmart(Anne, False) ::: Anne is smart. (Note: The conjecture is phrased as "Anne is smart," which is a claim to be evaluated. In logic form, it is represented as Smart(Anne, True), but since the task is to evaluate the truth of the conjecture, we represent it as a claim to be validated.)'}
  search_negation_False normalized_context: {'Fact': 'Furry(Anne, True) ::: Anne is furry.\nQuiet(Anne, True) ::: Anne is quiet.\nFurry(Charlie, True) ::: Charlie is furry.\nGreen(Charlie, True) ::: Charlie is green.\nFurry(Dave, True) ::: Dave is furry.\nYoung(Dave, True) ::: Dave is young.\nFurry(Fiona, True) ::: Fiona is furry.', 'and_or': '(Quiet(x,True) ∨ ¬Green(x,True)) ∧ (Quiet(x,True) ∨ ¬Furry(x,True))\n∧ (¬Young(x,True) ∨ Quiet(x,True))\n∧ (¬Quiet(x,True) ∨ Green(x,True))\n∧ (Green(x,True) ∨ ¬Smart(x,True)) ∧ (Green(x,True) ∨ ¬Nice(x,True))\n∧ (¬Nice(x,True) ∨ Furry(x,True))\n∧ (¬Nice(x,True) ∨ ¬Smart(x,True))\n∧ (¬Furry(x,True) ∨ Young(x,True))\n∧ (¬Furry(x,True) ∨ Cold(x,True))\n∧ (Nice(x,True) ∨ ¬Green(x,True)) ∧ (Nice(x,True) ∨ ¬Quiet(x,True))', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=A, False_run=C)

Ground truth: B, Predicted: C
  id: AttNeg-OWA-D0-4390
  original_context: Anne is furry. Dave is red. Harry is red. All nice people are smart. All green, furry people are not smart. All smart people are not red.
  question:  Dave is not red.
  ground_truth: B
  predicted_label: C
  search_negation_True final_choice: No final answer found in the text.
  search_negation_True final_answer: No complement found in the context.
  search_negation_True reasoning_step: 1. ['Red(Dave, True) ', 'Smart(x, False) ∨ Red(x, False)', 'Smart(Dave, False)']
2. ['Smart(Dave, False)', 'Nice(x, False) ∨ Smart(x, True)', 'Nice(Dave, False)']
  search_negation_True translated_context: {'Translated_Facts': 'Furry(Anne, True) ::: Anne is furry.\nRed(Dave, True) ::: Dave is red.\nRed(Harry, True) ::: Harry is red.', 'Translated_Rules': 'Nice($x, True) >>> Smart($x, True) ::: All nice people are smart.  \nGreen($x, True) ∨ Furry($x, True) >>> ¬Smart($x, True) ::: All green, furry people are not smart.  \nSmart($x, True) >>> ¬Red($x, True) ::: All smart people are not red.', 'Translated_Conjecture': '¬Red(Dave, True) ::: Dave is not red.'}
  search_negation_True normalized_context: {'Fact': 'Furry(Anne, True) ::: Anne is furry.\nRed(Dave, True) ::: Dave is red.\nRed(Harry, True) ::: Harry is red.', 'and_or': 'Nice(x, False) ∨ Smart(x, True)\n(Green(x, False) ∨ ¬Smart(x, True)) ∧ (Furry(x, False) ∨ ¬Smart(x, True))\n¬Smart(x, True) ∨ ¬Red(x, True)', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: No final answer found in the text.
  search_negation_False final_answer: No sos and complement found
  search_negation_False reasoning_step: 1. ['¬Red(Dave, True) ', 'Smart(x, False) ∨ Red(x, False)', '¬Red(Dave, True) ∨ Smart(x, False) ∨ Red(x, False)']
2. ['¬Red(Dave, True) ∨ Smart(x, False) ∨ Red(x, False)', 'Smart(x, False) ∨ Red(x, False)', '¬Red(Dave, True) ∨ Smart(x, False) ∨ Red(x, False)']
3. ['¬Red(Dave, True) ∨ Smart(x, False) ∨ Red(x, False)', '¬Red(Dave, True) ∨ Smart(x, False) ∨ Red(x, False)', '¬Red(Dave, True) ∨ Smart(x, False) ∨ Red(x, False)']
  search_negation_False translated_context: {'Translated_Facts': 'Furry(Anne, True) ::: Anne is furry.\nRed(Dave, True) ::: Dave is red.\nRed(Harry, True) ::: Harry is red.', 'Translated_Rules': 'Nice($x, True) >>> Smart($x, True) ::: All nice people are smart.  \nGreen($x, True) ∨ Furry($x, True) >>> ¬Smart($x, True) ::: All green, furry people are not smart.  \nSmart($x, True) >>> ¬Red($x, True) ::: All smart people are not red.', 'Translated_Conjecture': '¬Red(Dave, True) ::: Dave is not red.'}
  search_negation_False normalized_context: {'Fact': 'Furry(Anne, True) ::: Anne is furry.\nRed(Dave, True) ::: Dave is red.\nRed(Harry, True) ::: Harry is red.', 'and_or': 'Nice(x, False) ∨ Smart(x, True)\n(Green(x, False) ∨ ¬Smart(x, True)) ∧ (Furry(x, False) ∨ ¬Smart(x, True))\n¬Smart(x, True) ∨ ¬Red(x, True)', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=C, False_run=C)

Ground truth: B, Predicted: D
  id: ProofWriter_AttNeg-OWA-D5-200_Q12
  original_context: Anne is quiet. Charlie is cold. Charlie is not quiet. Charlie is young. Erin is nice. Erin is quiet. Erin is smart. Fiona is not quiet. Fiona is round. Fiona is young. All smart, cold people are round. If someone is cold then they are young. If someone is young and quiet then they are blue. If someone is round and not quiet then they are blue. Nice, blue people are cold. If someone is quiet then they are cold. If someone is quiet then they are cold. All blue people are smart.
  question:  Anne is not round.
  ground_truth: B
  predicted_label: D
  search_negation_True final_choice: A
  search_negation_True final_answer: True
  search_negation_True reasoning_step: 1. ['Round(Anne, True) ', '(Round(x,False) ∨ Quiet(x,True) ∨ Blue(x,True))', 'Quiet(Anne, True) ∨ Blue(Anne, True)']
2. ['Quiet(Anne, True) ∨ Blue(Anne, True)', '(Quiet(x,False) ∨ Cold(x,True))', 'Blue(Anne, True) ∨ Cold(Anne, True)']
3. ['Blue(Anne, True) ∨ Cold(Anne, True)', '(Blue(x,False) ∨ Cold(x,True))', 'Cold(Anne, True)']
4. ['Cold(Anne, True)', '(Cold(x,False) ∨ Round(x,True))', 'Round(Anne, True)']
5. ['Quiet(Anne, True) ∨ Blue(Anne, True)', '(Young(x,False) ∨ Quiet(x,False) ∨ Blue(x,True))', 'Blue(Anne, True) ∨ Young(Anne, False)']
6. ['Blue(Anne, True) ∨ Young(Anne, False)', '(Blue(x,False) ∨ Cold(x,True))', 'Young(Anne, False) ∨ Cold(Anne, True)']
7. ['Young(Anne, False) ∨ Cold(Anne, True)', '(Cold(x,False) ∨ Young(x,True))', 'Contradiction']
  search_negation_True translated_context: {'Translated_Facts': 'Quiet(Anne, True) ::: Anne is quiet.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, False) ::: Charlie is not quiet.\nYoung(Charlie, True) ::: Charlie is young.\nNice(Erin, True) ::: Erin is nice.\nQuiet(Erin, True) ::: Erin is quiet.\nSmart(Erin, True) ::: Erin is smart.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nRound(Fiona, True) ::: Fiona is round.\nYoung(Fiona, True) ::: Fiona is young.', 'Translated_Rules': '**\nSmart($x, True) ∨ Cold($x, True) >>> Round($x, True) ::: All smart, cold people are round.  \nQuiet($x, True) >>> Cold($x, True) ::: If someone is quiet then they are cold.  \nYoung($x, True) && Quiet($x, True) >>> Blue($x, True) ::: If someone is young and quiet then they are blue.  \nRound($x, True) && ¬Quiet($x, True) >>> Blue($x, True) ::: If someone is round and not quiet then they are blue.  \nNice($x, True) ∨ Blue($x, True) >>> Cold($x, True) ::: Nice, blue people are cold.  \nBlue($x, True) >>> Smart($x, True) ::: All blue people are smart.  \nCold($x, True) >>> Young($x, True) ::: If someone is cold then they are young.\n\n**', 'Translated_Conjecture': '**\nRound(Anne, False) ::: Anne is not round.'}
  search_negation_True normalized_context: {'Fact': 'Quiet(Anne, True) ::: Anne is quiet.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, False) ::: Charlie is not quiet.\nYoung(Charlie, True) ::: Charlie is young.\nNice(Erin, True) ::: Erin is nice.\nQuiet(Erin, True) ::: Erin is quiet.\nSmart(Erin, True) ::: Erin is smart.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nRound(Fiona, True) ::: Fiona is round.\nYoung(Fiona, True) ::: Fiona is young.', 'and_or': '(¬Smart(x,True) ∨ Round(x,True)) ∧ (¬Cold(x,True) ∨ Round(x,True))\n∧ (¬Quiet(x,True) ∨ Cold(x,True))\n∧ (¬Young(x,True) ∨ ¬Quiet(x,True) ∨ Blue(x,True))\n∧ (¬Round(x,True) ∨ Quiet(x,True) ∨ Blue(x,True))\n∧ (¬Nice(x,True) ∨ Cold(x,True)) ∧ (¬Blue(x,True) ∨ Cold(x,True))\n∧ (¬Blue(x,True) ∨ Smart(x,True))\n∧ (¬Cold(x,True) ∨ Young(x,True))', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: B
  search_negation_False final_answer: False
  search_negation_False reasoning_step: 1. ['Round(Anne, False) ', '(Cold(x,False) ∨ Round(x,True))', 'Cold(Anne, False)']
2. ['Cold(Anne, False)', '(Nice(x,False) ∨ Cold(x,True))', 'Nice(Anne, False)']
3. ['Round(Anne, False) ', '(Smart(x,False) ∨ Round(x,True))', 'Smart(Anne, False)']
4. ['Smart(Anne, False)', '(Blue(x,False) ∨ Smart(x,True))', 'Blue(Anne, False)']
5. ['Blue(Anne, False)', '(Round(x,False) ∨ Quiet(x,True) ∨ Blue(x,True))', 'Round(Anne, False) ∨ Quiet(Anne, True)']
6. ['Round(Anne, False) ∨ Quiet(Anne, True)', '(Cold(x,False) ∨ Round(x,True))', 'Quiet(Anne, True) ∨ Cold(Anne, False)']
7. ['Quiet(Anne, True) ∨ Cold(Anne, False)', '(Quiet(x,False) ∨ Cold(x,True))', 'Contradiction']
  search_negation_False translated_context: {'Translated_Facts': 'Quiet(Anne, True) ::: Anne is quiet.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, False) ::: Charlie is not quiet.\nYoung(Charlie, True) ::: Charlie is young.\nNice(Erin, True) ::: Erin is nice.\nQuiet(Erin, True) ::: Erin is quiet.\nSmart(Erin, True) ::: Erin is smart.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nRound(Fiona, True) ::: Fiona is round.\nYoung(Fiona, True) ::: Fiona is young.', 'Translated_Rules': '**\nSmart($x, True) ∨ Cold($x, True) >>> Round($x, True) ::: All smart, cold people are round.  \nQuiet($x, True) >>> Cold($x, True) ::: If someone is quiet then they are cold.  \nYoung($x, True) && Quiet($x, True) >>> Blue($x, True) ::: If someone is young and quiet then they are blue.  \nRound($x, True) && ¬Quiet($x, True) >>> Blue($x, True) ::: If someone is round and not quiet then they are blue.  \nNice($x, True) ∨ Blue($x, True) >>> Cold($x, True) ::: Nice, blue people are cold.  \nBlue($x, True) >>> Smart($x, True) ::: All blue people are smart.  \nCold($x, True) >>> Young($x, True) ::: If someone is cold then they are young.\n\n**', 'Translated_Conjecture': '**\nRound(Anne, False) ::: Anne is not round.'}
  search_negation_False normalized_context: {'Fact': 'Quiet(Anne, True) ::: Anne is quiet.\nCold(Charlie, True) ::: Charlie is cold.\nQuiet(Charlie, False) ::: Charlie is not quiet.\nYoung(Charlie, True) ::: Charlie is young.\nNice(Erin, True) ::: Erin is nice.\nQuiet(Erin, True) ::: Erin is quiet.\nSmart(Erin, True) ::: Erin is smart.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nRound(Fiona, True) ::: Fiona is round.\nYoung(Fiona, True) ::: Fiona is young.', 'and_or': '(¬Smart(x,True) ∨ Round(x,True)) ∧ (¬Cold(x,True) ∨ Round(x,True))\n∧ (¬Quiet(x,True) ∨ Cold(x,True))\n∧ (¬Young(x,True) ∨ ¬Quiet(x,True) ∨ Blue(x,True))\n∧ (¬Round(x,True) ∨ Quiet(x,True) ∨ Blue(x,True))\n∧ (¬Nice(x,True) ∨ Cold(x,True)) ∧ (¬Blue(x,True) ∨ Cold(x,True))\n∧ (¬Blue(x,True) ∨ Smart(x,True))\n∧ (¬Cold(x,True) ∨ Young(x,True))', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=A, False_run=B)

Ground truth: C, Predicted: A
  id: AttNeg-OWA-D0-2279
  original_context: Charlie is big. If someone is rough then they are nice. All nice, red people are blue. If Charlie is blue then Charlie is not smart. If Charlie is green then Charlie is smart. If someone is blue then they are red. All nice people are not rough. If Charlie is rough and Charlie is not nice then Charlie is big. Big, rough people are smart.
  question:  Charlie is not red.
  ground_truth: C
  predicted_label: A
  search_negation_True final_choice: A
  search_negation_True final_answer: True
  search_negation_True reasoning_step: 1. ['Red(Charlie, True) ', '(Red(x, False) ∨ Blue(x, True))', 'Blue(Charlie, True)']
2. ['Blue(Charlie, True)', 'Blue(x, False) ∨ Red(x, True)', 'Red(Charlie, True)']
3. ['Red(Charlie, True) ', 'Nice(x, False) ∨ Red(x, False) ∨ Blue(x, True)', 'Nice(Charlie, False) ∨ Blue(Charlie, True)']
4. ['Nice(Charlie, False) ∨ Blue(Charlie, True)', 'Rough(x, False) ∨ Nice(x, True)', 'Blue(Charlie, True) ∨ Rough(Charlie, False)']
5. ['Blue(Charlie, True) ∨ Rough(Charlie, False)', 'Blue(x, False) ∨ Red(x, True)', 'Rough(Charlie, False) ∨ Red(Charlie, True)']
6. ['Blue(Charlie, True)', 'Blue(Charlie, False) ∨ Smart(Charlie, False)', 'Smart(Charlie, False)']
7. ['Smart(Charlie, False)', '(Big(x, False) ∨ Smart(x, True))', 'Big(Charlie, False)']
8. ['Big(Charlie, False)', 'Big(Charlie, True)', 'Contradiction']
  search_negation_True translated_context: {'Translated_Facts': 'Big(Charlie, True) ::: Charlie is big.', 'Translated_Rules': '**\n\n**Conditional rules:**\nRough($x, True) >>> Nice($x, True) ::: If someone is rough then they are nice.  \nNice($x, True) && Red($x, True) >>> Blue($x, True) ::: All nice, red people are blue.  \nBlue(Charlie, True) >>> Smart(Charlie, False) ::: If Charlie is blue then Charlie is not smart.  \nGreen(Charlie, True) >>> Smart(Charlie, True) ::: If Charlie is green then Charlie is smart.  \nBlue($x, True) >>> Red($x, True) ::: If someone is blue then they are red.  \nNice($x, True) >>> Rough($x, False) ::: All nice people are not rough.  \nRough(Charlie, True) && Nice(Charlie, False) >>> Big(Charlie, True) ::: If Charlie is rough and Charlie is not nice then Charlie is big.  \nBig($x, True) && Rough($x, True) >>> Smart($x, True) ::: Big, rough people are smart.\n\n**Rules with Compound Predicates by comma:**\nNice($x, True) ∨ Red($x, True) >>> Blue($x, True) ::: All nice, red people are blue.  \nBig($x, True) ∨ Rough($x, True) >>> Smart($x, True) ::: Big, rough people are smart.\n\n**', 'Translated_Conjecture': '**\nRed(Charlie, False) ::: Charlie is not red.'}
  search_negation_True normalized_context: {'Fact': 'Big(Charlie, True) ::: Charlie is big.', 'and_or': 'Rough(x, False) ∨ Nice(x, True)\n¬Nice(x, True) ∨ ¬Red(x, True) ∨ Blue(x, True)\n¬Blue(Charlie, True) ∨ Smart(Charlie, False)\n¬Green(Charlie, True) ∨ Smart(Charlie, True)\n¬Blue(x, True) ∨ Red(x, True)\n¬Nice(x, True) ∨ Rough(x, False)\n¬Rough(Charlie, True) ∨ ¬Nice(Charlie, False) ∨ Big(Charlie, True)\n¬Big(x, True) ∨ ¬Rough(x, True) ∨ Smart(x, True)\n(¬Nice(x, True) ∨ Blue(x, True)) ∧ (¬Red(x, True) ∨ Blue(x, True))\n(¬Big(x, True) ∨ Smart(x, True)) ∧ (¬Rough(x, True) ∨ Smart(x, True))', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: No final answer found in the text.
  search_negation_False final_answer: No final answer found in the text.
  search_negation_False reasoning_step: 1. ['Red(Charlie, False) ', 'Blue(x, False) ∨ Red(x, True)', 'Blue(Charlie, False)']
2. ['Blue(Charlie, False)', '(Red(x, False) ∨ Blue(x, True))', 'Red(Charlie, False)']
3. ['Blue(Charlie, False)', '(Nice(x, False) ∨ Blue(x, True))', 'Nice(Charlie, False)']
4. ['Nice(Charlie, False)', 'Rough(x, False) ∨ Nice(x, True)', 'Rough(Charlie, False)']
5. ['Blue(Charlie, False)', 'Nice(x, False) ∨ Red(x, False) ∨ Blue(x, True)', 'Nice(Charlie, False) ∨ Red(Charlie, False)']
6. ['Nice(Charlie, False) ∨ Red(Charlie, False)', 'Rough(x, False) ∨ Nice(x, True)', 'Red(Charlie, False) ∨ Rough(Charlie, False)']
7. ['Red(Charlie, False) ∨ Rough(Charlie, False)', 'Blue(x, False) ∨ Red(x, True)', 'Rough(Charlie, False) ∨ Blue(Charlie, False)']
8. ['Nice(Charlie, False)', 'Rough(Charlie, False) ∨ Nice(Charlie, True) ∨ Big(Charlie, True)', 'Rough(Charlie, False) ∨ Big(Charlie, True)']
9. ['Nice(Charlie, False) ∨ Red(Charlie, False)', 'Rough(Charlie, False) ∨ Nice(Charlie, True) ∨ Big(Charlie, True)', 'Red(Charlie, False) ∨ Rough(Charlie, False) ∨ Big(Charlie, True)']
10. ['Red(Charlie, False) ∨ Rough(Charlie, False) ∨ Big(Charlie, True)', 'Blue(x, False) ∨ Red(x, True)', 'Rough(Charlie, False) ∨ Big(Charlie, True) ∨ Blue(Charlie, False)']
  search_negation_False translated_context: {'Translated_Facts': 'Big(Charlie, True) ::: Charlie is big.', 'Translated_Rules': '**\n\n**Conditional rules:**\nRough($x, True) >>> Nice($x, True) ::: If someone is rough then they are nice.  \nNice($x, True) && Red($x, True) >>> Blue($x, True) ::: All nice, red people are blue.  \nBlue(Charlie, True) >>> Smart(Charlie, False) ::: If Charlie is blue then Charlie is not smart.  \nGreen(Charlie, True) >>> Smart(Charlie, True) ::: If Charlie is green then Charlie is smart.  \nBlue($x, True) >>> Red($x, True) ::: If someone is blue then they are red.  \nNice($x, True) >>> Rough($x, False) ::: All nice people are not rough.  \nRough(Charlie, True) && Nice(Charlie, False) >>> Big(Charlie, True) ::: If Charlie is rough and Charlie is not nice then Charlie is big.  \nBig($x, True) && Rough($x, True) >>> Smart($x, True) ::: Big, rough people are smart.\n\n**Rules with Compound Predicates by comma:**\nNice($x, True) ∨ Red($x, True) >>> Blue($x, True) ::: All nice, red people are blue.  \nBig($x, True) ∨ Rough($x, True) >>> Smart($x, True) ::: Big, rough people are smart.\n\n**', 'Translated_Conjecture': '**\nRed(Charlie, False) ::: Charlie is not red.'}
  search_negation_False normalized_context: {'Fact': 'Big(Charlie, True) ::: Charlie is big.', 'and_or': 'Rough(x, False) ∨ Nice(x, True)\n¬Nice(x, True) ∨ ¬Red(x, True) ∨ Blue(x, True)\n¬Blue(Charlie, True) ∨ Smart(Charlie, False)\n¬Green(Charlie, True) ∨ Smart(Charlie, True)\n¬Blue(x, True) ∨ Red(x, True)\n¬Nice(x, True) ∨ Rough(x, False)\n¬Rough(Charlie, True) ∨ ¬Nice(Charlie, False) ∨ Big(Charlie, True)\n¬Big(x, True) ∨ ¬Rough(x, True) ∨ Smart(x, True)\n(¬Nice(x, True) ∨ Blue(x, True)) ∧ (¬Red(x, True) ∨ Blue(x, True))\n(¬Big(x, True) ∨ Smart(x, True)) ∧ (¬Rough(x, True) ∨ Smart(x, True))', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=A, False_run=C)

Ground truth: C, Predicted: B
  id: AttNeg-OWA-D0-6467
  original_context: Dave is blue. Gary is furry. Harry is cold. If someone is white and furry then they are not big. If someone is white then they are not big. Blue people are kind. If Harry is white and Harry is nice then Harry is not cold. All furry, kind people are nice. White, big people are not cold. All blue, kind people are not cold. If Gary is nice and Gary is furry then Gary is kind.
  question:  Gary is not kind.
  ground_truth: C
  predicted_label: B
  search_negation_True final_choice: No final answer found in the text.
  search_negation_True final_answer: No sos and complement found
  search_negation_True reasoning_step: 1. ['Kind(Gary, True) ', 'Kind(x, False) ∨ Nice(x, True)', 'Nice(Gary, True)']
2. ['Nice(Gary, True)', 'Nice(Gary, False) ∨ Furry(Gary, False) ∨ Kind(Gary, True)', 'Furry(Gary, False) ∨ Kind(Gary, True)']
3. ['Furry(Gary, False) ∨ Kind(Gary, True)', 'Furry(Gary, True)', 'Kind(Gary, True)']
4. ['Kind(Gary, True) ', 'Kind(x, False) ∨ Cold(x, False)', 'Cold(Gary, False)']
5. ['Kind(Gary, True) ', 'Furry(x, False) ∨ Kind(x, False) ∨ Nice(x, True)', 'Furry(Gary, False) ∨ Nice(Gary, True)']
6. ['Furry(Gary, False) ∨ Nice(Gary, True)', 'Furry(Gary, True)', 'Nice(Gary, True)']
7. ['Kind(Gary, True) ', 'Blue(x, False) ∨ Kind(x, False) ∨ Cold(x, False)', 'Blue(Gary, False) ∨ Cold(Gary, False)']
8. ['Kind(Gary, True)', 'Furry(x, False) ∨ Kind(x, False) ∨ Nice(x, True)', 'Furry(Gary, False) ∨ Nice(Gary, True)']
  search_negation_True translated_context: {'Translated_Facts': 'Blue(Dave, True) ::: Dave is blue.\nFurry(Gary, True) ::: Gary is furry.\nCold(Harry, True) ::: Harry is cold.', 'Translated_Rules': '**\n\n**Conditional rules:**\nWhite($x, True) && Furry($x, True) >>> Big($x, False) ::: If someone is white and furry then they are not big.  \nWhite($x, True) >>> Big($x, False) ::: If someone is white then they are not big.  \nBlue($x, True) >>> Kind($x, True) ::: Blue people are kind.  \nWhite(Harry, True) && Nice(Harry, True) >>> Cold(Harry, False) ::: If Harry is white and Harry is nice then Harry is not cold.  \nFurry($x, True) && Kind($x, True) >>> Nice($x, True) ::: All furry, kind people are nice.  \nWhite($x, True) && Big($x, True) >>> Cold($x, False) ::: White, big people are not cold.  \nBlue($x, True) && Kind($x, True) >>> Cold($x, False) ::: All blue, kind people are not cold.  \nNice(Gary, True) && Furry(Gary, True) >>> Kind(Gary, True) ::: If Gary is nice and Gary is furry then Gary is kind.\n\n**Rules with compound predicates by comma:**\nFurry($x, True) ∨ Kind($x, True) >>> Nice($x, True) ::: All furry, kind people are nice.  \nWhite($x, True) ∨ Big($x, True) >>> Cold($x, False) ::: White, big people are not cold.  \nBlue($x, True) ∨ Kind($x, True) >>> Cold($x, False) ::: All blue, kind people are not cold.\n\n**', 'Translated_Conjecture': '**\nKind(Gary, False) ::: Gary is not kind.'}
  search_negation_True normalized_context: {'Fact': 'Blue(Dave, True) ::: Dave is blue.\nFurry(Gary, True) ::: Gary is furry.\nCold(Harry, True) ::: Harry is cold.', 'and_or': 'White(x, False) ∨ Furry(x, False) ∨ Big(x, False)\nWhite(x, False) ∨ Big(x, False)\nBlue(x, False) ∨ Kind(x, True)\nWhite(Harry, False) ∨ Nice(Harry, False) ∨ Cold(Harry, False)\nFurry(x, False) ∨ Kind(x, False) ∨ Nice(x, True)\nWhite(x, False) ∨ Big(x, False) ∨ Cold(x, False)\nBlue(x, False) ∨ Kind(x, False) ∨ Cold(x, False)\nNice(Gary, False) ∨ Furry(Gary, False) ∨ Kind(Gary, True)\nFurry(x, False) ∨ Nice(x, True)\nKind(x, False) ∨ Nice(x, True)\nWhite(x, False) ∨ Cold(x, False)\nBig(x, False) ∨ Cold(x, False)\nBlue(x, False) ∨ Cold(x, False)\nKind(x, False) ∨ Cold(x, False)', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: B
  search_negation_False final_answer: False
  search_negation_False reasoning_step: 1. ['Kind(Gary, False) ', 'Blue(x, False) ∨ Kind(x, True)', 'Blue(Gary, False)']
2. ['Kind(Gary, False) ', 'Nice(Gary, False) ∨ Furry(Gary, False) ∨ Kind(Gary, True)', 'Nice(Gary, False) ∨ Furry(Gary, False)']
3. ['Nice(Gary, False) ∨ Furry(Gary, False)', 'Kind(x, False) ∨ Nice(x, True)', 'Furry(Gary, False) ∨ Kind(Gary, False)']
4. ['Furry(Gary, False) ∨ Kind(Gary, False)', 'Furry(Gary, True)', 'Kind(Gary, False)']
5. ['Nice(Gary, False) ∨ Furry(Gary, False)', 'Furry(x, False) ∨ Nice(x, True)', 'Furry(Gary, False)']
6. ['Furry(Gary, False)', 'Furry(Gary, True)', 'Contradiction']
  search_negation_False translated_context: {'Translated_Facts': 'Blue(Dave, True) ::: Dave is blue.\nFurry(Gary, True) ::: Gary is furry.\nCold(Harry, True) ::: Harry is cold.', 'Translated_Rules': '**\n\n**Conditional rules:**\nWhite($x, True) && Furry($x, True) >>> Big($x, False) ::: If someone is white and furry then they are not big.  \nWhite($x, True) >>> Big($x, False) ::: If someone is white then they are not big.  \nBlue($x, True) >>> Kind($x, True) ::: Blue people are kind.  \nWhite(Harry, True) && Nice(Harry, True) >>> Cold(Harry, False) ::: If Harry is white and Harry is nice then Harry is not cold.  \nFurry($x, True) && Kind($x, True) >>> Nice($x, True) ::: All furry, kind people are nice.  \nWhite($x, True) && Big($x, True) >>> Cold($x, False) ::: White, big people are not cold.  \nBlue($x, True) && Kind($x, True) >>> Cold($x, False) ::: All blue, kind people are not cold.  \nNice(Gary, True) && Furry(Gary, True) >>> Kind(Gary, True) ::: If Gary is nice and Gary is furry then Gary is kind.\n\n**Rules with compound predicates by comma:**\nFurry($x, True) ∨ Kind($x, True) >>> Nice($x, True) ::: All furry, kind people are nice.  \nWhite($x, True) ∨ Big($x, True) >>> Cold($x, False) ::: White, big people are not cold.  \nBlue($x, True) ∨ Kind($x, True) >>> Cold($x, False) ::: All blue, kind people are not cold.\n\n**', 'Translated_Conjecture': '**\nKind(Gary, False) ::: Gary is not kind.'}
  search_negation_False normalized_context: {'Fact': 'Blue(Dave, True) ::: Dave is blue.\nFurry(Gary, True) ::: Gary is furry.\nCold(Harry, True) ::: Harry is cold.', 'and_or': 'White(x, False) ∨ Furry(x, False) ∨ Big(x, False)\nWhite(x, False) ∨ Big(x, False)\nBlue(x, False) ∨ Kind(x, True)\nWhite(Harry, False) ∨ Nice(Harry, False) ∨ Cold(Harry, False)\nFurry(x, False) ∨ Kind(x, False) ∨ Nice(x, True)\nWhite(x, False) ∨ Big(x, False) ∨ Cold(x, False)\nBlue(x, False) ∨ Kind(x, False) ∨ Cold(x, False)\nNice(Gary, False) ∨ Furry(Gary, False) ∨ Kind(Gary, True)\nFurry(x, False) ∨ Nice(x, True)\nKind(x, False) ∨ Nice(x, True)\nWhite(x, False) ∨ Cold(x, False)\nBig(x, False) ∨ Cold(x, False)\nBlue(x, False) ∨ Cold(x, False)\nKind(x, False) ∨ Cold(x, False)', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=C, False_run=B)

Ground truth: C, Predicted: D
  id: AttNeg-OWA-D0-4322
  original_context: Anne is nice. Anne is rough. Anne is round. Dave is big. Fiona is not quiet. Harry is nice. Harry is quiet. If something is round and not quiet then it is nice. If something is rough then it is round. Nice, green things are rough. All nice things are rough. All quiet things are green. All big things are not green. If Harry is quiet then Harry is young. All round things are not big.
  question:  Dave is not round.
  ground_truth: C
  predicted_label: D
  search_negation_True final_choice: A
  search_negation_True final_answer: True
  search_negation_True reasoning_step: 1. ['Round(Dave, True) ', '(Nice(x,True) ∨ Round(x,False))', 'Nice(Dave, True)']
2. ['Nice(Dave, True)', '(Rough(x,True) ∨ Nice(x,False))', 'Rough(Dave, True)']
3. ['Rough(Dave, True)', '(Rough(x,False) ∨ Round(x,True))', 'Round(Dave, True)']
4. ['Round(Dave, True) ', '(Round(x,False) ∨ Big(x,False))', 'Big(Dave, False)']
5. ['Big(Dave, False)', 'Big(Dave, True)', 'Contradiction']
  search_negation_True translated_context: {'Translated_Facts': 'Nice(Anne, True) ::: Anne is nice.\nRough(Anne, True) ::: Anne is rough.\nRound(Anne, True) ::: Anne is round.\nBig(Dave, True) ::: Dave is big.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nNice(Harry, True) ::: Harry is nice.\nQuiet(Harry, True) ::: Harry is quiet.', 'Translated_Rules': '**\n\n**Rules with compound predicates by comma:**\nRound($x, True) ∨ ¬Quiet($x, True) >>> Nice($x, True) ::: If something is round and not quiet then it is nice.  \nRough($x, True) >>> Round($x, True) ::: If something is rough then it is round.  \nNice($x, True) ∨ Green($x, True) >>> Rough($x, True) ::: Nice, green things are rough.  \nNice($x, True) >>> Rough($x, True) ::: All nice things are rough.  \nQuiet($x, True) >>> Green($x, True) ::: All quiet things are green.  \nBig($x, True) >>> ¬Green($x, True) ::: All big things are not green.  \nQuiet(Harry, True) >>> Young(Harry, True) ::: If Harry is quiet then Harry is young.  \nRound($x, True) >>> ¬Big($x, True) ::: All round things are not big.\n\n**', 'Translated_Conjecture': '**\nRound(Dave, False) ::: Dave is not round.'}
  search_negation_True normalized_context: {'Fact': 'Nice(Anne, True) ::: Anne is nice.\nRough(Anne, True) ::: Anne is rough.\nRound(Anne, True) ::: Anne is round.\nBig(Dave, True) ::: Dave is big.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nNice(Harry, True) ::: Harry is nice.\nQuiet(Harry, True) ::: Harry is quiet.', 'and_or': '(Nice(x,True) ∨ ¬Round(x,True)) ∧ (Nice(x,True) ∨ Quiet(x,True))\n∧ (¬Rough(x,True) ∨ Round(x,True))\n∧ (Rough(x,True) ∨ ¬Nice(x,True)) ∧ (Rough(x,True) ∨ ¬Green(x,True))\n∧ (¬Nice(x,True) ∨ Rough(x,True))\n∧ (¬Quiet(x,True) ∨ Green(x,True))\n∧ (¬Big(x,True) ∨ ¬Green(x,True))\n∧ (¬Quiet(Harry,True) ∨ Young(Harry,True))\n∧ (¬Round(x,True) ∨ ¬Big(x,True))', 'either_or': None, 'biconditional': None}
  search_negation_False final_choice: B
  search_negation_False final_answer: False
  search_negation_False reasoning_step: 1. ['Round(Dave, False) ', '(Rough(x,False) ∨ Round(x,True))', 'Rough(Dave, False)']
2. ['Rough(Dave, False)', '(Rough(x,True) ∨ Nice(x,False))', 'Nice(Dave, False)']
3. ['Nice(Dave, False)', '(Nice(x,True) ∨ Quiet(x,True))', 'Quiet(Dave, True)']
4. ['Quiet(Dave, True)', '(Quiet(x,False) ∨ Green(x,True))', 'Green(Dave, True)']
5. ['Green(Dave, True)', '(Big(x,False) ∨ Green(x,False))', 'Big(Dave, False)']
6. ['Big(Dave, False)', 'Big(Dave, True)', 'Contradiction']
  search_negation_False translated_context: {'Translated_Facts': 'Nice(Anne, True) ::: Anne is nice.\nRough(Anne, True) ::: Anne is rough.\nRound(Anne, True) ::: Anne is round.\nBig(Dave, True) ::: Dave is big.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nNice(Harry, True) ::: Harry is nice.\nQuiet(Harry, True) ::: Harry is quiet.', 'Translated_Rules': '**\n\n**Rules with compound predicates by comma:**\nRound($x, True) ∨ ¬Quiet($x, True) >>> Nice($x, True) ::: If something is round and not quiet then it is nice.  \nRough($x, True) >>> Round($x, True) ::: If something is rough then it is round.  \nNice($x, True) ∨ Green($x, True) >>> Rough($x, True) ::: Nice, green things are rough.  \nNice($x, True) >>> Rough($x, True) ::: All nice things are rough.  \nQuiet($x, True) >>> Green($x, True) ::: All quiet things are green.  \nBig($x, True) >>> ¬Green($x, True) ::: All big things are not green.  \nQuiet(Harry, True) >>> Young(Harry, True) ::: If Harry is quiet then Harry is young.  \nRound($x, True) >>> ¬Big($x, True) ::: All round things are not big.\n\n**', 'Translated_Conjecture': '**\nRound(Dave, False) ::: Dave is not round.'}
  search_negation_False normalized_context: {'Fact': 'Nice(Anne, True) ::: Anne is nice.\nRough(Anne, True) ::: Anne is rough.\nRound(Anne, True) ::: Anne is round.\nBig(Dave, True) ::: Dave is big.\nQuiet(Fiona, False) ::: Fiona is not quiet.\nNice(Harry, True) ::: Harry is nice.\nQuiet(Harry, True) ::: Harry is quiet.', 'and_or': '(Nice(x,True) ∨ ¬Round(x,True)) ∧ (Nice(x,True) ∨ Quiet(x,True))\n∧ (¬Rough(x,True) ∨ Round(x,True))\n∧ (Rough(x,True) ∨ ¬Nice(x,True)) ∧ (Rough(x,True) ∨ ¬Green(x,True))\n∧ (¬Nice(x,True) ∨ Rough(x,True))\n∧ (¬Quiet(x,True) ∨ Green(x,True))\n∧ (¬Big(x,True) ∨ ¬Green(x,True))\n∧ (¬Quiet(Harry,True) ∨ Young(Harry,True))\n∧ (¬Round(x,True) ∨ ¬Big(x,True))', 'either_or': None, 'biconditional': None}
  normalized answers: (True_run=A, False_run=B)
